import React, { forwardRef, useRef, useMemo, useState, useImperativeHandle, useEffect } from 'react';
import Chart from 'chart.js';
import merge from 'lodash/merge';
import assign from 'lodash/assign';
import find from 'lodash/find';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var ChartComponent = forwardRef(function (props, ref) {
  var id = props.id,
      _props$height = props.height,
      height = _props$height === void 0 ? 150 : _props$height,
      _props$width = props.width,
      width = _props$width === void 0 ? 300 : _props$width,
      _props$redraw = props.redraw,
      redraw = _props$redraw === void 0 ? false : _props$redraw,
      type = props.type,
      data = props.data,
      _props$options = props.options,
      options = _props$options === void 0 ? {} : _props$options,
      _props$plugins = props.plugins,
      plugins = _props$plugins === void 0 ? [] : _props$plugins;
  var canvas = useRef(null);
  var computedData = useMemo(function () {
    if (typeof data === 'function') {
      return canvas.current ? data(canvas.current) : {};
    } else return merge({}, data);
  }, [data, canvas.current]);

  var _useState = useState(),
      chart = _useState[0],
      setChart = _useState[1];

  useImperativeHandle(ref, function () {
    return chart;
  }, [chart]);

  var renderChart = function renderChart() {
    if (!canvas.current) return;
    setChart(new Chart(canvas.current, {
      type: type,
      data: computedData,
      options: options,
      plugins: plugins
    }));
  };

  var onClick = function onClick(e) {
    if (!chart) return;
    var getDatasetAtEvent = props.getDatasetAtEvent,
        getElementAtEvent = props.getElementAtEvent,
        getElementsAtEvent = props.getElementsAtEvent;
    getDatasetAtEvent && getDatasetAtEvent(chart.getDatasetAtEvent(e), e);
    getElementAtEvent && getElementAtEvent(chart.getElementAtEvent(e), e);
    getElementsAtEvent && getElementsAtEvent(chart.getElementsAtEvent(e), e);
  };

  var updateChart = function updateChart() {
    if (!chart) return;

    if (options) {
      chart.options = Chart.helpers.configMerge(chart.options, options);
    }

    if (!chart.config.data) {
      chart.config.data = computedData;
      chart.update();
      return;
    }

    var _computedData$dataset = computedData.datasets,
        newDataSets = _computedData$dataset === void 0 ? [] : _computedData$dataset,
        newChartData = _objectWithoutPropertiesLoose(computedData, ["datasets"]);

    var _chart$config$data$da = chart.config.data.datasets,
        currentDataSets = _chart$config$data$da === void 0 ? [] : _chart$config$data$da;
    assign(chart.config.data, newChartData);
    chart.config.data.datasets = newDataSets.map(function (newDataSet) {
      var currentDataSet = find(currentDataSets, function (d) {
        return d.label === newDataSet.label && d.type === newDataSet.type;
      });
      if (!currentDataSet || !newDataSet.data) return newDataSet;

      if (!currentDataSet.data) {
        currentDataSet.data = [];
      } else {
        currentDataSet.data.splice(newDataSet.data.length);
      }

      assign(currentDataSet.data, newDataSet.data);
      return _extends({}, currentDataSet, newDataSet, {
        data: currentDataSet.data
      });
    });
    chart.update();
  };

  var destroyChart = function destroyChart() {
    if (chart) chart.destroy();
  };

  useEffect(function () {
    renderChart();
    return function () {
      return destroyChart();
    };
  }, []);
  useEffect(function () {
    if (redraw) {
      destroyChart();
      renderChart();
    } else {
      updateChart();
    }
  }, [props, computedData]);
  return React.createElement("canvas", {
    height: height,
    width: width,
    ref: canvas,
    id: id,
    onClick: onClick,
    "data-testid": 'canvas'
  });
});

var Line = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'line',
    ref: ref
  }));
});
var Bar = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'bar',
    ref: ref
  }));
});
var HorizontalBar = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'horizontalBar',
    ref: ref
  }));
});
var Radar = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'radar',
    ref: ref
  }));
});
var Doughnut = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'doughnut',
    ref: ref
  }));
});
var PolarArea = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'polarArea',
    ref: ref
  }));
});
var Bubble = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'bubble',
    ref: ref
  }));
});
var Pie = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'pie',
    ref: ref
  }));
});
var Scatter = forwardRef(function (props, ref) {
  return React.createElement(ChartComponent, Object.assign({}, props, {
    type: 'scatter',
    ref: ref
  }));
});

export default ChartComponent;
export { Bar, Bubble, Doughnut, HorizontalBar, Line, Pie, PolarArea, Radar, Scatter };
//# sourceMappingURL=index.modern.js.map
